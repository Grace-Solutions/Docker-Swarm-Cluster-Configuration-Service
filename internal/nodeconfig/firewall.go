package nodeconfig

import (
	"context"
	"fmt"
	"strings"

	"clusterctl/internal/config"
)

// configureFirewall configures iptables firewall rules on the node.
// Note: firewall.configurationEnabled=true only enables processing of rules, it does NOT disable the OS firewall.
// When firewall.configurationEnabled=false, we simply skip applying any rules (the OS firewall state is unchanged).
func (nc *NodeConfigurator) configureFirewall(ctx context.Context, node config.NodeConfig) error {
	hostname := node.SSHFQDNorIP
	fw := node.Firewall

	nc.log.Infow("configuring iptables firewall", "host", hostname)

	// Build the firewall configuration script
	var scriptBuilder strings.Builder

	// Script header
	scriptBuilder.WriteString(`#!/bin/bash
set -e

# VPS Firewall Configuration - Generated by dscotctl
#
# IMPORTANT DESIGN PRINCIPLES:
# 1. NEVER flush any chains - this preserves rules created by Docker, overlays, Keepalived
# 2. NEVER touch FORWARD chain - Docker manages this entirely
# 3. NEVER touch custom chains (DOCKER, DOCKER-USER, NETBIRD-*, ts-*, etc.)
# 4. Only ADD rules to INPUT chain using -A (append) or -I (insert)
# 5. Use -C (check) before -I to avoid duplicate rules
#
# This approach ensures we don't break:
# - Docker's iptables chains (DOCKER, DOCKER-USER, DOCKER-ISOLATION-STAGE-*)
# - Overlay networks (Netbird, Tailscale, WireGuard) and their rules
# - Keepalived VRRP multicast
# - Any existing rules from other services

# Ensure iptables and persistence are installed
if ! command -v iptables &>/dev/null; then
    apt-get update -qq && apt-get install -y iptables
fi

# Install iptables-persistent for rule persistence across reboots (non-interactive)
if ! dpkg -l iptables-persistent &>/dev/null 2>&1; then
    echo "Installing iptables-persistent for rule persistence..."
    DEBIAN_FRONTEND=noninteractive apt-get install -y iptables-persistent || true
fi

# Backup existing rules (full backup including all chains)
BACKUP_FILE="/root/iptables-backup-$(date +%Y%m%d-%H%M%S).rules"
iptables-save > "$BACKUP_FILE" 2>/dev/null || true
echo "Backed up existing rules to $BACKUP_FILE"

# === SAFETY RULES (inserted at top of INPUT chain) ===
# These ensure critical services always work, inserted with -I so they're evaluated first

# Allow loopback (always)
iptables -C INPUT -i lo -j ACCEPT 2>/dev/null || iptables -I INPUT -i lo -j ACCEPT

# Allow established/related connections (critical - allows return traffic)
iptables -C INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT 2>/dev/null || \
    iptables -I INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# === KEEPALIVED VRRP PROTECTION ===
# VRRP uses IP protocol 112 (not TCP/UDP), multicast to 224.0.0.18
iptables -C INPUT -p vrrp -j ACCEPT 2>/dev/null || iptables -I INPUT -p vrrp -j ACCEPT
iptables -C INPUT -d 224.0.0.18/32 -j ACCEPT 2>/dev/null || iptables -I INPUT -d 224.0.0.18/32 -j ACCEPT

# === OVERLAY NETWORK PROTECTION ===
# Allow traffic on overlay interfaces (these services manage their own rules, we just ensure interface traffic works)
for iface in wt0 wt+ tailscale0 wg0 wg+; do
    iptables -C INPUT -i $iface -j ACCEPT 2>/dev/null || iptables -I INPUT -i $iface -j ACCEPT 2>/dev/null || true
done

# Allow overlay network ports (Netbird 51820/UDP, Tailscale 41641/UDP, WireGuard 51820/UDP)
iptables -C INPUT -p udp --dport 51820 -j ACCEPT 2>/dev/null || iptables -I INPUT -p udp --dport 51820 -j ACCEPT
iptables -C INPUT -p udp --dport 41641 -j ACCEPT 2>/dev/null || iptables -I INPUT -p udp --dport 41641 -j ACCEPT

# === DOCKER PROTECTION ===
# Allow traffic on Docker bridge interfaces (Docker manages FORWARD chain, we just ensure INPUT works)
iptables -C INPUT -i docker0 -j ACCEPT 2>/dev/null || iptables -I INPUT -i docker0 -j ACCEPT
iptables -C INPUT -i docker_gwbridge -j ACCEPT 2>/dev/null || iptables -I INPUT -i docker_gwbridge -j ACCEPT

# Allow Docker Swarm ports (required for cluster communication)
# 2377/TCP - cluster management, 7946/TCP+UDP - node communication, 4789/UDP - overlay network
iptables -C INPUT -p tcp --dport 2377 -j ACCEPT 2>/dev/null || iptables -I INPUT -p tcp --dport 2377 -j ACCEPT
iptables -C INPUT -p tcp --dport 7946 -j ACCEPT 2>/dev/null || iptables -I INPUT -p tcp --dport 7946 -j ACCEPT
iptables -C INPUT -p udp --dport 7946 -j ACCEPT 2>/dev/null || iptables -I INPUT -p udp --dport 7946 -j ACCEPT
iptables -C INPUT -p udp --dport 4789 -j ACCEPT 2>/dev/null || iptables -I INPUT -p udp --dport 4789 -j ACCEPT

echo "Safety rules applied (Keepalived VRRP, Docker, overlay networks protected)"
echo "Note: Existing chains (DOCKER, DOCKER-USER, NETBIRD-*, ts-*) are NOT modified"

# === USER-DEFINED RULES ===

`)

	// Apply profiles first (in order)
	for _, profile := range fw.Profiles {
		if !profile.Enabled {
			continue
		}
		profileScript := nc.getProfileScript(profile.Name)
		if profileScript != "" {
			scriptBuilder.WriteString(fmt.Sprintf("# Profile: %s\n", profile.Name))
			scriptBuilder.WriteString(profileScript)
			scriptBuilder.WriteString("\n\n")
		}
	}

	// Apply custom port rules (after profiles)
	for _, rule := range fw.Ports {
		if !rule.Enabled {
			continue
		}
		ruleScript := nc.getPortRuleScript(rule)
		if ruleScript != "" {
			if rule.Comment != "" {
				scriptBuilder.WriteString(fmt.Sprintf("# %s\n", rule.Comment))
			} else {
				scriptBuilder.WriteString("# Port rule\n")
			}
			scriptBuilder.WriteString(ruleScript)
			scriptBuilder.WriteString("\n")
		}
	}

	// Script footer - save rules persistently
	scriptBuilder.WriteString(`
# === SAVE RULES FOR PERSISTENCE ACROSS REBOOTS ===
mkdir -p /etc/iptables

# Save current rules
iptables-save > /etc/iptables/rules.v4 2>/dev/null || true
ip6tables-save > /etc/iptables/rules.v6 2>/dev/null || true

# Enable netfilter-persistent service if available
if systemctl is-enabled netfilter-persistent &>/dev/null 2>&1; then
    echo "netfilter-persistent already enabled"
elif systemctl list-unit-files netfilter-persistent.service &>/dev/null 2>&1; then
    systemctl enable netfilter-persistent 2>/dev/null || true
    echo "Enabled netfilter-persistent service"
fi

# Also save via netfilter-persistent if available
if command -v netfilter-persistent &>/dev/null; then
    netfilter-persistent save 2>/dev/null || true
fi

echo "Rules saved to /etc/iptables/rules.v4 (will persist across reboots)"
echo "Firewall configuration complete"
`)

	// Execute the script
	script := scriptBuilder.String()
	if _, stderr, err := nc.sshPool.Run(ctx, hostname, script); err != nil {
		return fmt.Errorf("firewall configuration failed: %w (stderr: %s)", err, stderr)
	}

	nc.log.Infow("firewall configured successfully", "host", hostname)
	return nil
}

// getProfileScript returns the iptables commands for a predefined profile.
// IMPORTANT: Profiles must NEVER flush chains or modify FORWARD chain.
// They should only use -A (append) or -I (insert) with -C (check) to avoid duplicates.
func (nc *NodeConfigurator) getProfileScript(profileName string) string {
	switch profileName {
	case config.FirewallProfileBlockAllPublic:
		// NOTE: loopback and established/related are already allowed in safety rules section
		return `# Block all inbound from public IPs (non-RFC1918)
# Set default DROP policy for INPUT chain
# Traffic from private networks, overlays, Docker, and Keepalived is allowed by safety rules
# WARNING: This will block all public inbound traffic not explicitly allowed!
iptables -P INPUT DROP
echo "INPUT policy set to DROP - only allowed traffic will be accepted"`

	case config.FirewallProfileAllowAllPrivate:
		// Use -C to check before -A to avoid duplicate rules
		return `# Allow all traffic from private networks (RFC1918 + RFC6598 CGNAT)
iptables -C INPUT -s 10.0.0.0/8 -j ACCEPT 2>/dev/null || iptables -A INPUT -s 10.0.0.0/8 -j ACCEPT
iptables -C INPUT -s 172.16.0.0/12 -j ACCEPT 2>/dev/null || iptables -A INPUT -s 172.16.0.0/12 -j ACCEPT
iptables -C INPUT -s 192.168.0.0/16 -j ACCEPT 2>/dev/null || iptables -A INPUT -s 192.168.0.0/16 -j ACCEPT
iptables -C INPUT -s 100.64.0.0/10 -j ACCEPT 2>/dev/null || iptables -A INPUT -s 100.64.0.0/10 -j ACCEPT
echo "Private network traffic allowed (10.x, 172.16.x, 192.168.x, 100.64.x)"`

	case config.FirewallProfileHarden:
		return `# Security hardening profile

# Enable SYN flood protection via tcp_syncookies (persist across reboots)
echo 1 > /proc/sys/net/ipv4/tcp_syncookies
if ! grep -q "net.ipv4.tcp_syncookies" /etc/sysctl.conf 2>/dev/null; then
    echo "net.ipv4.tcp_syncookies = 1" >> /etc/sysctl.conf
fi
sysctl -w net.ipv4.tcp_syncookies=1 >/dev/null

# Rate limit SSH - max 4 new connections per minute per IP (use -C to check first)
iptables -C INPUT -p tcp --dport 22 -m state --state NEW -m recent --set --name SSH_RATE 2>/dev/null || \
    iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --set --name SSH_RATE
iptables -C INPUT -p tcp --dport 22 -m state --state NEW -m recent --update --seconds 60 --hitcount 5 --name SSH_RATE -j DROP 2>/dev/null || \
    iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --update --seconds 60 --hitcount 5 --name SSH_RATE -j DROP

# Rate limit ICMP (ping) - allow but limit
iptables -C INPUT -p icmp -m limit --limit 10/second --limit-burst 20 -j ACCEPT 2>/dev/null || \
    iptables -A INPUT -p icmp -m limit --limit 10/second --limit-burst 20 -j ACCEPT

# Drop invalid packets
iptables -C INPUT -m conntrack --ctstate INVALID -j DROP 2>/dev/null || \
    iptables -A INPUT -m conntrack --ctstate INVALID -j DROP

echo "Hardening rules applied (SSH rate limiting, SYN flood protection, ICMP limits)"`

	default:
		nc.log.Warnw("unknown firewall profile", "profile", profileName)
		return ""
	}
}

// getPortRuleScript generates iptables commands for a custom port rule.
func (nc *NodeConfigurator) getPortRuleScript(rule config.FirewallPortRule) string {
	var commands []string
	action := rule.GetAction()
	sources := rule.GetSources()

	// Expand source shortcuts to actual CIDR ranges
	expandedSources := nc.expandSources(sources)

	// Process each port/range in the list
	for _, portItem := range rule.RangeList {
		var portStr string
		switch v := portItem.(type) {
		case float64:
			portStr = fmt.Sprintf("%d", int(v))
		case int:
			portStr = fmt.Sprintf("%d", v)
		case string:
			// Could be a range like "4500-6500"
			portStr = v
		default:
			nc.log.Warnw("invalid port type in RangeList", "type", fmt.Sprintf("%T", v), "value", v)
			continue
		}

		// Handle port range (e.g., "4500-6500" -> "4500:6500" for iptables)
		portArg := strings.ReplaceAll(portStr, "-", ":")

		// Generate rules for each protocol and each source
		for _, proto := range rule.Protocol {
			proto = strings.ToLower(proto)
			if proto != "tcp" && proto != "udp" {
				nc.log.Warnw("invalid protocol in port rule", "protocol", proto)
				continue
			}

			for _, source := range expandedSources {
				var sourceArg string
				if source == "0.0.0.0/0" || source == "any" || source == "" {
					sourceArg = "" // No source restriction
				} else {
					sourceArg = fmt.Sprintf("-s %s ", source)
				}

				comment := rule.Comment
				if comment == "" {
					comment = fmt.Sprintf("Custom %s port %s", strings.ToUpper(proto), portStr)
				}

				cmd := fmt.Sprintf("iptables -A INPUT -p %s --dport %s %s-j %s -m comment --comment \"%s\"",
					proto, portArg, sourceArg, action, comment)
				commands = append(commands, strings.TrimSpace(cmd))
			}
		}
	}

	return strings.Join(commands, "\n")
}

// expandSources expands source shortcuts to actual CIDR ranges.
func (nc *NodeConfigurator) expandSources(sources []string) []string {
	var expanded []string
	for _, src := range sources {
		switch src {
		case "private":
			// RFC1918 private ranges
			expanded = append(expanded, "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16")
		case "cgnat":
			// RFC6598 CGNAT range
			expanded = append(expanded, "100.64.0.0/10")
		case "any", "":
			expanded = append(expanded, "0.0.0.0/0")
		default:
			// Assume it's a CIDR
			expanded = append(expanded, src)
		}
	}
	return expanded
}

